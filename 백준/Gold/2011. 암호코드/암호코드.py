import sys
# DP/점화식
# A1 - Z26 (1-26)
# BEAN(4자리) 암호가 25114일 때, 해석 알파벳 경우의 수
# DP 연상법
    # (중복 계산 가능성 인식) "1214"와 "1215"는 처음 세 숫자의 해석이 동일
    # (최적 부분 구조 확인) n번째 숫자까지의 해석 방법 수는 n-1번째와 n-2번째까지의 해석 방법 수에 의존한다
    # 핵심 점화식: 1214 면 14 해석 경우(+ (n-2)) 이고 4로 해석 경우(+ (n-1)) => 둘의 합
num = sys.stdin.readline().strip() #1214
answer = 0

# 1. 예외처리: num이 0으로 시작하면 잘못된 암호임
if not num or num[0] == '0':
    print(0)
    exit()

# 오! 1214의 경우의 수를 (중복 부분 찾아서 DP화하려면) 마지막 두자리에 대한 해석에 따라 경우의 수 갈리겠군
# 121(4)의 경우의 수 + 12(14)의 경우의 수 합치면 1214(즉, 4번째 자리까지)의 경우의 수 되겠군
# 그럼 4번째 자리까지의 수 나중에 또 중복돼서 쓸 수 있겠군(DP화 성공)
# 2. DP 배열 초기화 *** DP 그릇부터 만들자
dp = [0] * (len(num) + 1) # dp[1]은 첫번쨰자리까지의 경우의수 ~ dp[len(num)]은 len(num)자리까지의 경우의 수
# 첫번째까지의 DP와 2번째자리부터의 DP 나눠서! 분리해서 정의하기
dp[0] = dp[1] = 1

# DP[2]부터 점화식 정의하기
# 한자리 해석의 모든 경우 = 1204 or 1234 1214
for i in range(2, len(num)+ 1):
    if num[i-1] != '0': # 해당 자리 # 모든 경우에 대한 최소 조건 
        dp[i] += dp[i-1] # 다음 자리 정의

    # 두 자리 해석의 모든 경우
    two_digit = int(num[i-2:i])
    if 10 <= two_digit <= 26:
        dp[i] += dp[i-2]

    dp[i] %= 1000000

print(dp[len(num)])

# 두자리 해석 경우







